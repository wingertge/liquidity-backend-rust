<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `object` attr in crate `juniper_codegen`."><meta name="keywords" content="rust, rustlang, rust-lang, object"><title>juniper_codegen::object - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc attr"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../juniper_codegen/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><div class="sidebar-elems"><p class='location'><a href='index.html'>juniper_codegen</a></p><script>window.sidebarCurrent = {name: 'object', ty: 'attr', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/juniper_codegen/lib.rs.html#357-360' title='goto source code'>[src]</a></span><span class='in-band'>Attribute Macro <a href='index.html'>juniper_codegen</a>::<wbr><a class="attr" href=''>object</a></span></h1><pre class='rust attr'>#[object]</pre><div class='docblock'><p>The <code>object</code> proc macro is the primary way of defining GraphQL resolvers
that can not be implemented with the GraphQLObject derive.</p>
<p>It enables you to write GraphQL field resolvers for a type by declaring a
regular Rust <code>impl</code> block. Under the hood, the procedural macro implements
the GraphQLType trait.</p>
<p><code>object</code> comes with many features that allow customization of
your fields, all of which are detailed below.</p>
<h3 id="getting-started" class="section-header"><a href="#getting-started">Getting Started</a></h3>
<p>This simple example will show you the most basic use of <code>object</code>.
More advanced use cases are introduced step by step.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// So we can declare it as a plain struct without any members.</span>
<span class="kw">struct</span> <span class="ident">Query</span>;

<span class="comment">// We prefix the impl Block with the procedural macro.</span>
<span class="attribute">#[<span class="ident">juniper</span>::<span class="ident">object</span>]</span>
<span class="kw">impl</span> <span class="ident">Query</span> {

    <span class="comment">// A **warning**: only GraphQL fields can be specified in this impl block.</span>
    <span class="comment">// If you want to define normal methods on the struct,</span>
    <span class="comment">// you have to do so in a separate, normal `impl` block.</span>


    <span class="comment">// This defines a simple, static field which does not require any context.</span>
    <span class="comment">// You can return any value that implements the `GraphQLType` trait.</span>
    <span class="comment">// This trait is implemented for:</span>
    <span class="comment">//  - basic scalar types like bool, &amp;str, String, i32, f64</span>
    <span class="comment">//  - GraphQL compatible wrappers like Option&lt;_&gt;, Vec&lt;_&gt;.</span>
    <span class="comment">//  - types which use the `#derive[juniper::GraphQLObject]`</span>
    <span class="comment">//  - `object` structs.</span>
    <span class="comment">//</span>
    <span class="comment">// An important note regarding naming:</span>
    <span class="comment">// By default, field names will be converted to camel case.</span>
    <span class="comment">// For your GraphQL queries, the field will be available as `apiVersion`.</span>
    <span class="comment">//</span>
    <span class="comment">// You can also manually customize the field name if required. (See below)</span>
    <span class="kw">fn</span> <span class="ident">api_version</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span> {
        <span class="string">&quot;0.1&quot;</span>
    }

    <span class="comment">// This field takes two arguments.</span>
    <span class="comment">// GraphQL arguments are just regular function parameters.</span>
    <span class="comment">// **Note**: in Juniper, arguments are non-nullable by default.</span>
    <span class="comment">//           for optional arguments, you have to specify them with Option&lt;T&gt;.</span>
    <span class="kw">fn</span> <span class="ident">add</span>(<span class="ident">a</span>: <span class="ident">f64</span>, <span class="ident">b</span>: <span class="ident">f64</span>, <span class="ident">c</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">f64</span> {
        <span class="ident">a</span> <span class="op">+</span> <span class="ident">b</span> <span class="op">+</span> <span class="ident">c</span>.<span class="ident">unwrap_or</span>(<span class="number">0.0</span>)
    }
}</pre></div>
<h2 id="accessing-self" class="section-header"><a href="#accessing-self">Accessing self</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">Person</span> {
    <span class="ident">first_name</span>: <span class="ident">String</span>,
    <span class="ident">last_name</span>: <span class="ident">String</span>,
}

<span class="kw">impl</span> <span class="ident">Person</span> {
    <span class="comment">// The full name method is useful outside of GraphQL,</span>
    <span class="comment">// so we define it as a normal method.</span>
    <span class="kw">fn</span> <span class="ident">build_full_name</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">String</span> {
        <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{} {}&quot;</span>, <span class="self">self</span>.<span class="ident">first_name</span>, <span class="self">self</span>.<span class="ident">last_name</span>)
    }
}

<span class="attribute">#[<span class="ident">juniper</span>::<span class="ident">object</span>]</span>
<span class="kw">impl</span> <span class="ident">Person</span> {
    <span class="kw">fn</span> <span class="ident">first_name</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span><span class="ident">str</span> {
        <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">first_name</span>
    }

    <span class="kw">fn</span> <span class="ident">last_name</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span><span class="ident">str</span> {
        <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">last_name</span>
    }

    <span class="kw">fn</span> <span class="ident">full_name</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">String</span> {
        <span class="self">self</span>.<span class="ident">build_full_name</span>()
    }
}</pre></div>
<h2 id="context--executor" class="section-header"><a href="#context--executor">Context (+ Executor)</a></h2>
<p>You can specify a context that will be available across
all your resolvers during query execution.</p>
<p>The Context can be injected into your resolvers by just
specifying an argument with the same type as the context
(but as a reference).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">


<span class="kw">struct</span> <span class="ident">Context</span> {
    <span class="ident">db</span>: <span class="ident">DbPool</span>,
}

<span class="comment">// Mark our struct for juniper.</span>
<span class="kw">impl</span> <span class="ident">juniper</span>::<span class="ident">Context</span> <span class="kw">for</span> <span class="ident">Context</span> {}

<span class="kw">struct</span> <span class="ident">Query</span>;

<span class="attribute">#[<span class="ident">juniper</span>::<span class="ident">object</span>(
    <span class="comment">// Here we specify the context type for this object.</span>
    <span class="ident">Context</span> <span class="op">=</span> <span class="ident">Context</span>,
)]</span>
<span class="kw">impl</span> <span class="ident">Query</span> {
    <span class="comment">// Context is injected by specifying a argument</span>
    <span class="comment">// as a reference to the Context.</span>
    <span class="kw">fn</span> <span class="ident">user</span>(<span class="ident">context</span>: <span class="kw-2">&amp;</span><span class="ident">Context</span>, <span class="ident">id</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">User</span><span class="op">&gt;</span> {
        <span class="ident">context</span>.<span class="ident">db</span>.<span class="ident">user</span>(<span class="ident">id</span>)
    }

    <span class="comment">// You can also gain access to the executor, which</span>
    <span class="comment">// allows you to do look aheads.</span>
    <span class="kw">fn</span> <span class="ident">with_executor</span>(<span class="ident">executor</span>: <span class="kw-2">&amp;</span><span class="ident">Executor</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> {
        <span class="kw">let</span> <span class="ident">info</span> <span class="op">=</span> <span class="ident">executor</span>.<span class="ident">look_ahead</span>();
        <span class="comment">// ...</span>
        <span class="bool-val">true</span>
    }
}
</pre></div>
<h2 id="customization-documentation-renaming-" class="section-header"><a href="#customization-documentation-renaming-">Customization (Documentation, Renaming, ...)</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">InternalQuery</span>;

<span class="comment">// Doc comments can be used to specify graphql documentation.</span>
<span class="doccomment">/// GRAPHQL DOCUMENTATION.</span>
<span class="doccomment">/// More info for GraphQL users....</span>
<span class="attribute">#[<span class="ident">juniper</span>::<span class="ident">object</span>(
    <span class="comment">// You can rename the type for GraphQL by specifying the name here.</span>
    <span class="ident">name</span> <span class="op">=</span> <span class="string">&quot;Query&quot;</span>,
    <span class="comment">// You can also specify a description here.</span>
    <span class="comment">// If present, doc comments will be ignored.</span>
    <span class="ident">description</span> <span class="op">=</span> <span class="string">&quot;...&quot;</span>,
)]</span>
<span class="kw">impl</span> <span class="ident">InternalQuery</span> {
    <span class="comment">// Documentation doc comments also work on fields.</span>
    <span class="doccomment">/// GraphQL description...</span>
    <span class="kw">fn</span> <span class="ident">field_with_description</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> { <span class="bool-val">true</span> }

    <span class="comment">// Fields can also be customized with the #[graphql] attribute.</span>
    <span class="attribute">#[<span class="ident">graphql</span>(
        <span class="comment">// overwrite the public name</span>
        <span class="ident">name</span> <span class="op">=</span> <span class="string">&quot;actualFieldName&quot;</span>,
        <span class="comment">// Can be used instead of doc comments.</span>
        <span class="ident">description</span> <span class="op">=</span> <span class="string">&quot;field description&quot;</span>,
    )]</span>
    <span class="kw">fn</span> <span class="ident">internal_name</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> { <span class="bool-val">true</span> }

    <span class="comment">// Fields can be deprecated too.</span>
    <span class="attribute">#[<span class="ident">graphql</span>(
        <span class="ident">deprecated</span> <span class="op">=</span> <span class="string">&quot;deprecatin info...&quot;</span>,
        <span class="comment">// Note: just &quot;deprecated,&quot; without a description works too.</span>
    )]</span>
    <span class="kw">fn</span> <span class="ident">deprecated_field_simple</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> { <span class="bool-val">true</span> }


    <span class="comment">// Customizing field arguments is a little awkward right now.</span>
    <span class="comment">// This will improve once [RFC 2564](https://github.com/rust-lang/rust/issues/60406)</span>
    <span class="comment">// is implemented, which will allow attributes on function parameters.</span>

    <span class="attribute">#[<span class="ident">graphql</span>(
        <span class="ident">arguments</span>(
            <span class="ident">arg1</span>(
                <span class="comment">// You can specify default values.</span>
                <span class="comment">// A default can be any valid expression that yields the right type.</span>
                <span class="ident">default</span> <span class="op">=</span> <span class="bool-val">true</span>,
                <span class="ident">description</span> <span class="op">=</span> <span class="string">&quot;Argument description....&quot;</span>,
            ),
            <span class="ident">arg2</span>(
                <span class="ident">default</span> <span class="op">=</span> <span class="bool-val">false</span>,
                <span class="ident">description</span> <span class="op">=</span> <span class="string">&quot;arg2 description...&quot;</span>,
            ),
        ),
    )]</span>
    <span class="kw">fn</span> <span class="ident">args</span>(<span class="ident">arg1</span>: <span class="ident">bool</span>, <span class="ident">arg2</span>: <span class="ident">bool</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> {
        <span class="ident">arg1</span> <span class="kw-2">&amp;</span><span class="op">&amp;</span> <span class="ident">arg2</span>
    }
}</pre></div>
<h2 id="lifetimes-generics-and-custom-scalars" class="section-header"><a href="#lifetimes-generics-and-custom-scalars">Lifetimes, Generics and custom Scalars</a></h2>
<p>Lifetimes work just like you'd expect.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">WithLifetime</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">value</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span>,
}

<span class="attribute">#[<span class="ident">juniper</span>::<span class="ident">object</span>]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">WithLifetime</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">value</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span><span class="ident">str</span> {
        <span class="self">self</span>.<span class="ident">value</span>
    }
}
</pre></div>
<p>Juniper has support for custom scalars.
Mostly you will only need the default scalar type juniper::DefaultScalarValue.</p>
<p>You can easily specify a custom scalar though.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">


<span class="kw">struct</span> <span class="ident">Query</span>;

<span class="attribute">#[<span class="ident">juniper</span>::<span class="ident">object</span>(
    <span class="ident">Scalar</span> <span class="op">=</span> <span class="ident">MyCustomScalar</span>,
)]</span>
<span class="kw">impl</span> <span class="ident">Query</span> {
    <span class="comment">// ...</span>
}</pre></div>
</div></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "juniper_codegen";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>