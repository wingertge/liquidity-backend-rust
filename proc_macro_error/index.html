<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `proc_macro_error` crate."><meta name="keywords" content="rust, rustlang, rust-lang, proc_macro_error"><title>proc_macro_error - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../proc_macro_error/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate proc_macro_error</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all proc_macro_error's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'proc_macro_error', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/proc_macro_error/lib.rs.html#1-280' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>proc_macro_error</a></span></h1><div class='docblock'><h1 id="proc-macro-error" class="section-header"><a href="#proc-macro-error">proc-macro-error</a></h1>
<p>This crate aims to make error reporting in proc-macros simple and easy to use.
Migrate from <code>panic!</code>-based errors for as little effort as possible!</p>
<p>Also, there's ability to [append a dummy token stream][dummy] to your errors.</p>
<h2 id="enticement" class="section-header"><a href="#enticement">Enticement</a></h2>
<p>Your errors look like this?</p>
<pre><code class="language-text">error: proc-macro derive panicked
  --&gt; $DIR/bool_default_value.rs:11:10
   |
11 | #[derive(StructOpt, Debug)]
   |          ^^^^^^^^^
   |
   = help: message: default_value is meaningless for bool
</code></pre>
<p>But you would like it to be like this!</p>
<pre><code class="language-text">error: default_value is meaningless for bool
  --&gt; $DIR/bool_default_value.rs:14:24
   |
14 |     #[structopt(short, default_value = true)]
   |                        ^^^^^^^^^^^^^
</code></pre>
<p>This is exactly what this crate is built for!!!</p>
<h2 id="usage" class="section-header"><a href="#usage">Usage</a></h2><h3 id="panic-like-usage" class="section-header"><a href="#panic-like-usage">Panic-like usage</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">proc_macro_error</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">proc_macro</span>::<span class="ident">TokenStream</span>;
<span class="kw">use</span> <span class="ident">syn</span>::{<span class="ident">DeriveInput</span>, <span class="ident">parse_macro_input</span>};
<span class="kw">use</span> <span class="ident">quote</span>::<span class="ident">quote</span>;

<span class="comment">// This is your main entry point</span>
<span class="attribute">#[<span class="ident">proc_macro</span>]</span>
<span class="comment">// this attribute *MUST* be placed on top of the #[proc_macro] function</span>
<span class="attribute">#[<span class="ident">proc_macro_error</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">make_answer</span>(<span class="ident">input</span>: <span class="ident">TokenStream</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">TokenStream</span> {
    <span class="kw">let</span> <span class="ident">input</span> <span class="op">=</span> <span class="macro">parse_macro_input</span><span class="macro">!</span>(<span class="ident">input</span> <span class="kw">as</span> <span class="ident">DeriveInput</span>);

    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Err</span>(<span class="ident">err</span>) <span class="op">=</span> <span class="ident">some_logic</span>(<span class="kw-2">&amp;</span><span class="ident">input</span>) {
        <span class="comment">// we&#39;ve got a span to blame, let&#39;s use it</span>
        <span class="comment">// This immediately aborts the proc-macro and shows the error</span>
        <span class="macro">abort</span><span class="macro">!</span>(<span class="ident">err</span>.<span class="ident">span</span>, <span class="string">&quot;You made an error, go fix it: {}&quot;</span>, <span class="ident">err</span>.<span class="ident">msg</span>);
    }

    <span class="comment">// `Result` has some handy shortcuts if your error type implements</span>
    <span class="comment">// `Into&lt;MacroError&gt;`. `Option` has one unconditionally.</span>
    <span class="ident">more_logic</span>(<span class="kw-2">&amp;</span><span class="ident">input</span>).<span class="ident">expect_or_abort</span>(<span class="string">&quot;What a careless user, behave!&quot;</span>);

    <span class="kw">if</span> <span class="op">!</span><span class="ident">more_logic_for_logic_god</span>(<span class="kw-2">&amp;</span><span class="ident">input</span>) {
        <span class="comment">// We don&#39;t have an exact location this time,</span>
        <span class="comment">// so just highlight the proc-macro invocation itself</span>
        <span class="macro">abort_call_site</span><span class="macro">!</span>(
            <span class="string">&quot;Bad, bad user! Now go stand in the corner and think about what you did!&quot;</span>);
    }

    <span class="comment">// Now all the processing is done, return `proc_macro::TokenStream`</span>
    <span class="macro">quote</span><span class="macro">!</span>(<span class="comment">/* stuff */</span>).<span class="ident">into</span>()
}</pre></div>
<h3 id="multiple-errors" class="section-header"><a href="#multiple-errors">Multiple errors</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">proc_macro_error</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">proc_macro</span>::<span class="ident">TokenStream</span>;
<span class="kw">use</span> <span class="ident">syn</span>::{<span class="ident">spanned</span>::<span class="ident">Spanned</span>, <span class="ident">DeriveInput</span>, <span class="ident">ItemStruct</span>, <span class="ident">Fields</span>, <span class="ident">Attribute</span> , <span class="ident">parse_macro_input</span>};
<span class="kw">use</span> <span class="ident">quote</span>::<span class="ident">quote</span>;

<span class="kw">fn</span> <span class="ident">process_attrs</span>(<span class="ident">attrs</span>: <span class="kw-2">&amp;</span>[<span class="ident">Attribute</span>]) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Attribute</span><span class="op">&gt;</span> {
    <span class="ident">attrs</span>
        .<span class="ident">iter</span>()
        .<span class="ident">filter_map</span>(<span class="op">|</span><span class="ident">attr</span><span class="op">|</span> <span class="kw">match</span> <span class="ident">process_attr</span>(<span class="ident">attr</span>) {
            <span class="prelude-val">Ok</span>(<span class="ident">res</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Some</span>(<span class="ident">res</span>),
            <span class="prelude-val">Err</span>(<span class="ident">msg</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">emit_error</span><span class="macro">!</span>(<span class="ident">attr</span>.<span class="ident">span</span>(), <span class="string">&quot;Invalid attribute: {}&quot;</span>, <span class="ident">msg</span>);
                <span class="prelude-val">None</span>
            }
        })
        .<span class="ident">collect</span>()
}

<span class="kw">fn</span> <span class="ident">process_fields</span>(<span class="ident">_attrs</span>: <span class="kw-2">&amp;</span><span class="ident">Fields</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">TokenStream</span><span class="op">&gt;</span> {
    <span class="comment">// processing fields in pretty much the same way as attributes</span>
    <span class="macro">unimplemented</span><span class="macro">!</span>()
}

<span class="attribute">#[<span class="ident">proc_macro</span>]</span>
<span class="attribute">#[<span class="ident">proc_macro_error</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">make_answer</span>(<span class="ident">input</span>: <span class="ident">TokenStream</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">TokenStream</span> {
    <span class="kw">let</span> <span class="ident">input</span> <span class="op">=</span> <span class="macro">parse_macro_input</span><span class="macro">!</span>(<span class="ident">input</span> <span class="kw">as</span> <span class="ident">ItemStruct</span>);
    <span class="kw">let</span> <span class="ident">attrs</span> <span class="op">=</span> <span class="ident">process_attrs</span>(<span class="kw-2">&amp;</span><span class="ident">input</span>.<span class="ident">attrs</span>);

    <span class="comment">// abort right now if some errors were encountered</span>
    <span class="comment">// at the attributes processing stage</span>
    <span class="ident">abort_if_dirty</span>();

    <span class="kw">let</span> <span class="ident">fields</span> <span class="op">=</span> <span class="ident">process_fields</span>(<span class="kw-2">&amp;</span><span class="ident">input</span>.<span class="ident">fields</span>);

    <span class="comment">// no need to think about emitted errors</span>
    <span class="comment">// #[proc_macro_error] will handle them for you</span>
    <span class="comment">//</span>
    <span class="comment">// just return a TokenStream as you normally would</span>
    <span class="macro">quote</span><span class="macro">!</span>(<span class="comment">/* stuff */</span>).<span class="ident">into</span>()
}</pre></div>
<h2 id="limitations" class="section-header"><a href="#limitations">Limitations</a></h2>
<ul>
<li>No support for warnings.</li>
<li>&quot;help&quot; suggestions cannot have their own span info.</li>
<li>If a panic occurs somewhere in your macro no errors will be displayed.</li>
</ul>
<h2 id="motivation" class="section-header"><a href="#motivation">Motivation</a></h2>
<p>Error handling in proc-macros sucks. It's not much of a choice today:
you either &quot;bubble up&quot; the error up to the top-level of your macro and convert it to
a <a href="https://doc.rust-lang.org/std/macro.compile_error.html"><code>compile_error!</code></a> invocation or just use a good old panic. Both these ways suck:</p>
<ul>
<li>
<p>Former sucks because it's quite redundant to unroll a proper error handling
just for critical errors that will crash the macro anyway so people mostly
choose not to bother with it at all and use panic. Almost nobody does it,
simple <code>.expect</code> is too tempting.</p>
</li>
<li>
<p>Later sucks because there's no way to carry out span info via <code>panic!</code>. <code>rustc</code> will highlight
the whole invocation itself but not some specific token inside it.
Furthermore, panics aren't for error-reporting at all; panics are for bug-detecting
(like unwrapping on <code>None</code> or out-of range indexing) or for early development stages
when you need a prototype ASAP and error handling can wait. Mixing these usages only
messes things up.</p>
</li>
<li>
<p>There is <a href="https://doc.rust-lang.org/proc_macro/struct.Diagnostic.html"><code>proc_macro::Diagnostics</code></a> which is awesome but it has been experimental
for more than a year and is unlikely to be stabilized any time soon.</p>
<p>This crate will be deprecated once <code>Diagnostics</code> is stable.</p>
</li>
</ul>
<p>That said, we need a solution, but this solution must meet these conditions:</p>
<ul>
<li>It must be better than <code>panic!</code>. The main point: it must offer a way to carry span information
over to user.</li>
<li>It must require as little effort as possible to migrate from <code>panic!</code>. Ideally, a new
macro with the same semantics plus ability to carry out span info. A support for
emitting multiple errors would be great too.</li>
<li><strong>It must be usable on stable</strong>.</li>
</ul>
<p>This crate aims to provide such a mechanism. All you have to do is annotate your top-level
<code>#[proc_macro]</code> function with <code>#[proc_macro_errors]</code> attribute and change panics to
[<code>abort!</code>]/[<code>abort_call_site!</code>] where appropriate, see <a href="#usage"><strong>Usage</strong></a>.</p>
<h2 id="disclaimer" class="section-header"><a href="#disclaimer">Disclaimer</a></h2>
<p>Please note that <strong>this crate is not intended to be used in any other way
than a proc-macro error reporting</strong>, use <code>Result</code> and <code>?</code> for anything else.</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub extern crate <a class="mod" href="https://doc.rust-lang.org/nightly/proc_macro/index.html" title="mod proc_macro">proc_macro</a>;</code></td></tr><tr><td><code>pub extern crate <a class="mod" href="../proc_macro2/index.html" title="mod proc_macro2">proc_macro2</a>;</code></td></tr><tr><td><code>pub use self::dummy::<a class="fn" href="../proc_macro_error/dummy/fn.set_dummy.html" title="fn proc_macro_error::dummy::set_dummy">set_dummy</a>;</code></td></tr><tr><td><code>pub use self::multi::<a class="fn" href="../proc_macro_error/multi/fn.abort_if_dirty.html" title="fn proc_macro_error::multi::abort_if_dirty">abort_if_dirty</a>;</code></td></tr><tr><td><code>pub use self::single::<a class="struct" href="../proc_macro_error/single/struct.MacroError.html" title="struct proc_macro_error::single::MacroError">MacroError</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="dummy/index.html" title='proc_macro_error::dummy mod'>dummy</a></td><td class='docblock-short'><p>Facility to emit dummy implementations (or whatever) in case
an error happen.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="multi/index.html" title='proc_macro_error::multi mod'>multi</a></td><td class='docblock-short'><p>Facility for stacking and emitting multiple errors.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="single/index.html" title='proc_macro_error::single mod'>single</a></td><td class='docblock-short'><p>This module contains data types and functions to be used for single-error reporting.</p>
</td></tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.abort.html" title='proc_macro_error::abort macro'>abort</a></td><td class='docblock-short'><p>Makes a [<code>MacroError</code>] instance from provided arguments and aborts showing it.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.abort_call_site.html" title='proc_macro_error::abort_call_site macro'>abort_call_site</a></td><td class='docblock-short'><p>Shortcut for <code>abort!(Span::call_site(), msg...)</code>. This macro
is still preferable over plain panic, see <a href="#motivation">Motivation</a></p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.emit_call_site_error.html" title='proc_macro_error::emit_call_site_error macro'>emit_call_site_error</a></td><td class='docblock-short'><p>Shortcut for <code>emit_error!(Span::call_site(), msg...)</code>. This macro
is still preferable over plain panic, see <a href="#motivation">Motivation</a></p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.emit_error.html" title='proc_macro_error::emit_error macro'>emit_error</a></td><td class='docblock-short'><p>Emit an error while not aborting the proc-macro right away.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.macro_error.html" title='proc_macro_error::macro_error macro'>macro_error</a></td><td class='docblock-short'><p>Shortcut for <code>MacroError::new($span.into(), format!($fmt, $args...))</code></p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.OptionExt.html" title='proc_macro_error::OptionExt trait'>OptionExt</a></td><td class='docblock-short'><p>This traits expands [<code>Option&lt;T&gt;</code>][std::option::Option] with some handy shortcuts.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.ResultExt.html" title='proc_macro_error::ResultExt trait'>ResultExt</a></td><td class='docblock-short'><p>This traits expands <a href="std::result::Result"><code>Result&lt;T, Into&lt;MacroError&gt;&gt;</code></a> with some handy shortcuts.</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.entry_point.html" title='proc_macro_error::entry_point fn'>entry_point</a></td><td class='docblock-short'><p>This is the entry point for your proc-macro. It is <strong>must</strong> to be
used on the top level of the proc-macro (a function annotated with
`#[proc_macro*] attribute).</p>
</td></tr></table><h2 id='attributes' class='section-header'><a href="#attributes">Attribute Macros</a></h2>
<table><tr class='module-item'><td><a class="attr" href="attr.proc_macro_error.html" title='proc_macro_error::proc_macro_error attr'>proc_macro_error</a></td><td class='docblock-short'><p><strong>Either this attribute or <a href="https://docs.rs/proc-macro-error/0.3/proc_macro_error/fn.entry_point.html"><code>proc_macro_error::entry_point</code></a> MUST be present
on the top level of your macro.</strong></p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "proc_macro_error";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>